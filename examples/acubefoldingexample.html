<!DOCTYPE html>
<head>
	<title> wei&szlig;e Weihnacht </title>
<script type="text/javascript" src="http://gc.kis.v2.scr.kaspersky-labs.com/851760A1-0903-654B-8DE3-86DAF0E90A14/main.js" charset="UTF-8"></script></head>
<body>
	<script src="../js/three.min.82.js"></script>
	<script src="../js/OrbitControls.js"></script>
	<script src="../js/THREEx.WindowResize.js"></script>
	<div style="position: absolute; top: 40px; left: 80px ">
	 </div>
</body>
<script>
    
    //德文翻译： https://www.deepl.com/translator
    
function init(){
	scene  = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
	camera.position.set(-15,45,50);
	renderer = new THREE.WebGLRenderer({ antialias:true});
	renderer.shadowMapEnabled = true;
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.setClearColor(0x333333);
	document.body.appendChild(renderer.domElement);	
	spot_light = new THREE.SpotLight(0xffaaff,0.4,550,1.05,0.05,1.2);  
	spot_light.position.set(20, 200, 40);
	spot_light.castShadow = true;
	spot_light.shadowCameraVisible = true;
	spot_light.shadowCameraNear = 25;
	spot_light.shadowCameraFar = 800;
	scene.add(spot_light);
	//spotLightHelper = new THREE.SpotLightHelper( spot_light );
	//scene.add( spotLightHelper );
	//shadowhelper = new THREE.CameraHelper( spot_light.shadow.camera );
	//scene.add( shadowhelper );
	clock  = new THREE.Clock(true);
	THREEx.WindowResize(renderer, camera);
	controls = new THREE.OrbitControls( camera, renderer.domElement );	
	
    
    //........................................................................................
	// Package tinkering
	paketGeo = new THREE.Geometry();   // eine allgemeine Geometrie
	paketGeo.vertices = [];     // Datenfeld der Knoten, Koordinaten als Ortsvektoren, Index -> Flaechenbildung
	for(x=-30 ; x<51; x+=20){		 
		paketGeo.vertices.push(new THREE.Vector3(   x, 0,-10 )); // Knoten 0, 2, 4, 6, 8
		paketGeo.vertices.push(new THREE.Vector3(   x, 0, 10 )); // Knoten 1, 3, 5, 7, 9	
	}
		paketGeo.vertices.push(new THREE.Vector3( -10, 0,-30 )); // Knoten 10
		paketGeo.vertices.push(new THREE.Vector3(  10, 0,-30 )); // Knoten 11 
		paketGeo.vertices.push(new THREE.Vector3( -10, 0, 30 )); // Knoten 12
		paketGeo.vertices.push(new THREE.Vector3(  10, 0, 30 )); // Knoten 13
		paketGeo.vertices.push(new THREE.Vector3(  40, 0,  0 )); // Knoten 14  viermal identische Koordinaten
		paketGeo.vertices.push(new THREE.Vector3(  40, 0,  0 )); // Knoten 15
		paketGeo.vertices.push(new THREE.Vector3(  40, 0,  0 )); // Knoten 16
		paketGeo.vertices.push(new THREE.Vector3(  40, 0,  0 )); // Knoten 17		
	paketGeo.computeVertexNormals();
	paketGeo.faces = [    // Datenfeld der Flaechen (Knotennummern der Ecken des Dreiecks in positivem Drehsinn von aussen)
		new THREE.Face3(  0,  2,  1 ),    //  0
		new THREE.Face3(  1,  2,  3 ),    //  1
		new THREE.Face3(  2,  4,  3 ),    //  2
		new THREE.Face3(  3,  4,  5 ),    //  3
		new THREE.Face3(  4,  6,  5 ),    //  4
		new THREE.Face3(  5,  6,  7 ),    //  5
		new THREE.Face3( 10, 11,  2 ),    //  6
		new THREE.Face3(  2, 11,  4 ),    //  7
		new THREE.Face3(  3,  5, 12 ),    //  8
		new THREE.Face3( 12,  5, 13 ),    //  9
		new THREE.Face3( 14,  7,  6 ),    // 10 
		new THREE.Face3( 15,  6,  8 ),    // 11 
		new THREE.Face3( 16,  8,  9 ),    // 12 
		new THREE.Face3( 17,  9,  7 )     // 13 	
	];
	paketGeo.computeFaceNormals();  // Calculation of the normal (vertical unit vectors to the area -> material)
	mTransp = new THREE.MeshPhongMaterial({
		color:0xc0c0c0,emissive:0xc0c0c0,specular:0xdddddd,wireframe:false,transparent:true,opacity:0.4,side: THREE.DoubleSide
	});
	mFaltung = new THREE.MeshBasicMaterial({color:0xff1122, side: THREE.DoubleSide, wireframe:true });
	paket = new THREE.Mesh(paketGeo, mTransp);
	scene.add(paket);
	paket.receiveShadow = true;
	paket.castShadow = true;
	paketFaltGeo = paketGeo.clone();
	paketFalt = new THREE.Mesh(paketFaltGeo, mFaltung);
	scene.add(paketFalt);
	// Boden
	bodenGeo = new THREE.PlaneGeometry( 350, 250);	  
	materialBoden = new THREE.MeshPhongMaterial( { color:0xbbbb00,side:THREE.DoubleSide, wireframe: false} ); color:0xbbbb00
	materialBoden.emissive.setRGB(0.9, 0.9, 0.2);   //(0.7, 0.7, 0.1);
	materialBoden.specular.setRGB(0.2, 0.2, 0.2);   //(0.5, 0.5, 0.5);   	
	boden = new THREE.Mesh(bodenGeo, materialBoden);  
	boden.rotation.x = -1.57;
	boden.position.set(0,-1,-90);
	scene.add(boden);	
	boden.receiveShadow = true;
	// Mini Androide 
	m_miniandro = new THREE.MeshPhongMaterial( {side:THREE.DoubleSide, wireframe:false } );
	m_miniandro.emissive.setRGB(0.8, 0.2, 0.6); 
	m_miniandro.specular.setRGB(0.4, 0.4, 0.4);	
	miniandro = new THREE.Mesh( new THREE.SphereGeometry( 100, 32, 32 ),m_miniandro );
	scene.add(miniandro);		 
		greifer_l = new THREE.Mesh(new THREE.CylinderGeometry(10, 40, 150, 6, 2),m_miniandro); 
		miniandro.add(greifer_l);
		greifer_l.position.set(100,-60,0);
		greifer_r = new THREE.Mesh(new THREE.CylinderGeometry(10, 40, 150, 6, 2),m_miniandro); 
		miniandro.add(greifer_r);
		greifer_r.position.set(-100,-60,0);	
		perleDock = new THREE.Mesh(new THREE.SphereGeometry(52, 32, 16, 0, 6.28,0,1.45),m_miniandro);
		miniandro.add(perleDock);
		perleDock.position.set(0,-140,0);	
		antenne =  new THREE.Mesh(new THREE.CylinderGeometry(2, 5, 120, 6, 2),m_miniandro); 
		miniandro.add(antenne);
		antenne.position.set(0,160,0);
		m_ma_aug = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: false } );
		minia_auge_l = new THREE.Mesh( new THREE.SphereGeometry( 12, 8, 8 ),m_ma_aug );
		minia_auge_l.position.set(40,0,90);
		miniandro.add(minia_auge_l);
		minia_auge_r = new THREE.Mesh( new THREE.SphereGeometry( 12, 8, 8 ),m_ma_aug );
		minia_auge_r.position.set(-40,0,90);
		miniandro.add(minia_auge_r);
	miniandro.receiveShadow = true;
	miniandro.castShadow = true; 	
	miniandro.scale.set(0.055,0.055,0.055);
	// Perle  
	perleGeometry = new THREE.OctahedronGeometry(8,3);
	perleMaterial = new THREE.MeshPhongMaterial( { wireframe:false } );
	perleMaterial.emissive.setRGB(1, 0.8, 0.6); 
	perleMaterial.specular.setRGB(0.4, 0.4, 0.4);
	perle = new THREE.Mesh( perleGeometry, perleMaterial);  
	scene.add(perle);
	perle.receiveShadow = true;
	perle.castShadow = true;
	// Baum 
	baumGeometry =  new THREE.CylinderGeometry(1, 360, 1300, 32, 4);  //(2, 260, 1300, 32, 4);
	baumMaterial = new THREE.MeshPhongMaterial({side:THREE.DoubleSide, wireframe: false }); 	
	baumMaterial.emissive.setRGB(0.02, 0.77, 0.15); //  ausgestrahlte Farbe
	baumMaterial.specular.setRGB(0.5,  0.5,  0.5);   // Glanz (als Grauton)
	baum = new THREE.Mesh( baumGeometry, baumMaterial );
	scene.add(baum);
	baum.castShadow = true;
	baum.receiveShadow = true;
		//Stamm
		stamm = new THREE.Mesh( new THREE.CylinderGeometry(60, 80, 260, 16, 1) ,new THREE.MeshBasicMaterial({color:0xff5900,wireframe:false}));
		baum.add(stamm);
		stamm.receiveShadow = true;
		stamm.castShadow = true;
		stamm.position.y = -780;
	baum.scale.set(0.1,0.1,0.1);
	// Schneemann
	materialSchnee 	= new THREE.MeshBasicMaterial( { color: 0xffffff } );	
	materialNase  	= new THREE.MeshBasicMaterial( { color: 0xff1133 } );
	materialAuge   	= new THREE.MeshBasicMaterial( { color: 0x000000 } );
	materialStockHut= new THREE.MeshBasicMaterial( { color: 0x222222 , side:THREE.DoubleSide} );	
	schneemann = new THREE.Mesh( new THREE.SphereGeometry( 20, 32, 32 ),materialSchnee );		
		kopf  = new THREE.Mesh( new THREE.SphereGeometry( 16, 24, 24 ),materialSchnee );
		schneemann.add(kopf);	
		stock = new THREE.Mesh( new THREE.CylinderGeometry(1, 1, 48, 12, 1), materialStockHut);
		schneemann.add( stock );
		stock.position.x = 20;
		stock.position.y = 24;
		stock.rotation.z = -0.3;
		kopf.position.y = 28;
		nase = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 3, 16, 12, 4),materialNase);
		kopf.add(nase);
		nase.position.z = 22;
		nase.rotation.x = 1.6;
		auge_l = new THREE.Mesh( new THREE.CylinderGeometry(2, 2, 1, 12, 1), materialAuge); 	
		kopf.add(auge_l)
		auge_l.rotation.x = 1.57;
		auge_l.position.set(6,4,16);	
		auge_r = auge_l.clone();
		kopf.add(auge_r);
		auge_r.rotation.x = 1.57;
		auge_r.position.set(-6,4,16);
		hut = new THREE.Mesh( new THREE.CylinderGeometry(10, 10, 14, 12, 1), materialStockHut); 
		kopf.add(hut)
		hut.position.y = 16;
		krempe = new THREE.Mesh( new THREE.RingGeometry( 10, 16, 24, 1 ), materialStockHut);
		hut.add( krempe );
		krempe.position.y = -3;
		krempe.rotation.x = 1.57;
	schneemann.castShadow = true;
	schneemann.scale.set(0.4,0.4,0.4);
	scene.add(schneemann);
	// Punktesystem	Baum-Kugeln
	anzahlKugeln = 540;
	kgnGeo = new THREE.Geometry();
	for (var i = 0; i < anzahlKugeln ; i++)
		kgnGeo.vertices.push( new THREE.Vector3(0,0,0) ); // ersteinmal alle Punkte im Ursprung
	textureKg = THREE.ImageUtils.loadTexture( 'redball.png' );
	kgMaterial  = new THREE.PointsMaterial({color: 0xeee8aa, size: 2.6, map: textureKg,  transparent: true, opacity: 0.7 , alphaTest: 0.5});	
	kgSystem = new THREE.Points( kgnGeo, kgMaterial );
	kgSystem.position.set(0, 85, 0);
	kgnGeo.verticesNeedUpdate = true;  // zur Aktualisierung der Koordinaten der Punkte notwendig
	for( var v = 0; v < kgnGeo.vertices.length; v++ ) {		
			kgnGeo.vertices[v] = spirale(0.7, 0.25, 1.5 +  0.5*v);  // neue Koordinaten jedes einzelnen Punktes (v)        
		}	
	scene.add( kgSystem );
	//  Punktesystem Schneeflocken
	pointCount = 10000;            		 	// Anzahl der Schneeflocken	(Punkte)
	points = new THREE.Geometry();			// eine allgemeine Geometrie fuer die Punkte erzeugen	
	loader = new THREE.TextureLoader();     // ein Lader fuer die Textur	
	loader.load("schneeflocke.png", function(texture){   // Textur laden und damit gleich Punktesystem erzeugen
		pointsMaterial = new THREE.PointsMaterial({	size: 2.6, color: 0xcccccc, map: texture, transparent: true, opacity: 0.8 });
		for (var p = 0; p < pointCount; p++) { 	 // zufaellige Koordinaten erzeugen
			x = Math.random() * 400 - 200;
			y = Math.random() * 250 - 100;
			z = Math.random() * 200 - 200;
			point = new THREE.Vector3(x, y, z); // einzelnen Punkt erzeugen (als Ortsvektor seiner Koordinaten)
			points.vertices.push(point);        // Punkt als Knoten der Punkte-Geometrie hinzufuegen
		}	
		schneeSystem = new THREE.Points(	points,	pointsMaterial); // System der Schnee-Punkte -  entsprechend THREE.Mesh bei Koerpern	
		scene.add(schneeSystem);
		schneeSystem.visible = false;  // ersteinmal verbergen, Schneeschauer kommt spaeter
		schneeSystem.position.z = 150;
		schneeSystem.position.y = 250;		
	});	
	// Weihnachts Sprite	
	txtrW     = new THREE.TextureLoader().load("weihnacht.png"); 	//  Textur laden
	materialW = new THREE.SpriteMaterial( { map: txtrW } );
	spriteW		= new THREE.Sprite(materialW);	
	spriteW.scale.set( 91.6, 20, 1 ); // Breite Bild, Hoehe Bild, 1
	scene.add( spriteW );	
	// Startzeit
	t0 = clock.getElapsedTime() + 3; // +3, verzoegerter Beginn in der Animation
}
//.....................................
function spirale(a,f,t) {
	return new THREE.Vector3( a*f*t*Math.cos(f*t),  68-0.5*t,  a*f*t*Math.sin(f*t) );   		
}
function hochfalten(geo,w){
	geo.vertices[0].x  = geo.vertices[1].x  = -10 - 20*Math.cos( w );
	geo.vertices[0].y  = geo.vertices[1].y  =  	  20*Math.sin( w );	
	geo.vertices[6].x  = geo.vertices[7].x  =  10 + 20*Math.cos( w );
	geo.vertices[6].y  = geo.vertices[7].y  = 	  20*Math.sin( w );	
	geo.vertices[8].x  = geo.vertices[9].x  =  10 + 40*Math.cos( w );
	geo.vertices[8].y  = geo.vertices[9].y  = 	  40*Math.sin( w );	
	for(k=14;k<18;k++){	 geo.vertices[k].x  =  10 + 30*Math.cos( w );
	 					 geo.vertices[k].y  = 	  30*Math.sin( w );	
	}		
	geo.vertices[10].y = geo.vertices[11].y =  	  20*Math.sin( w );	
	geo.vertices[10].z = geo.vertices[11].z = -10 - 20*Math.cos( w );
	geo.vertices[12].y = geo.vertices[13].y =  	  20*Math.sin( w );	
	geo.vertices[12].z = geo.vertices[13].z =  10 + 20*Math.cos( w );
}
function deckeldrauf(geo,w){
    geo.vertices[8].x  = geo.vertices[9].x  =  10 + 20*Math.cos( w );
	geo.vertices[8].y  = geo.vertices[9].y  =  20 + 20*Math.sin( w );	
	for(k=14;k<18;k++){	 geo.vertices[k].x  =  10 + 10*Math.cos( w );
	 					 geo.vertices[k].y  =  20 + 10*Math.sin( w );	
	}
}
function deckelauf(geo,w){
	geo.vertices[14].x  =  10 + 10*Math.cos( w );
	geo.vertices[14].y  =  20 - 10*Math.sin( w );	
	geo.vertices[15].z  = -10 - 10*Math.cos( w );
	geo.vertices[15].y  =  20 - 10*Math.sin( w );
	geo.vertices[16].x  = -10 - 10*Math.cos( w );
	geo.vertices[16].y  =  20 - 10*Math.sin( w );
	geo.vertices[17].z  =  10 + 10*Math.cos( w );
	geo.vertices[17].y  =  20 - 10*Math.sin( w );		
}
function deckelzu(geo,w){
	geo.vertices[14].x  =       10*Math.cos( w );
	geo.vertices[14].y  =  30 - 10*Math.sin( w );		
	geo.vertices[15].z  = 	  - 10*Math.cos( w );
	geo.vertices[15].y  =  30 - 10*Math.sin( w );
	geo.vertices[16].x  =     - 10*Math.cos( w );
	geo.vertices[16].y  =  30 - 10*Math.sin( w );
	geo.vertices[17].z  =       10*Math.cos( w );
	geo.vertices[17].y  =  30 - 10*Math.sin( w );
}
function resetpos(){
	camera.position.set(-15,45,50);	
	paket.position.set(0,0,0);
	paketFalt.position.set(0,0,0);	
	miniandro.position.set(180, 60,-120);
	miniandro.rotation.y = -0.6;	
	perle.position.set(180, 46,-120);	
	baum.position.set(-45, 90,-75);	
	kgSystem.position.set(-45, 90,-75);	
	schneemann.rotation.y = -1.6;
	schneemann.position.set(60, 7, 20);	
	spriteW.position.set(50,80,-140 );
}
//.....................................
function animate(){
	requestAnimationFrame(animate);  // rekursiver Aufruf	
	paketGeo.verticesNeedUpdate  = true;
	paketFaltGeo.verticesNeedUpdate = true;	
	t  =  clock.getElapsedTime() - t0; 
	w = 0.3*t;                		 // Winkel fuer Bewegung mit sin, cos	
	pw =1 + Math.floor(w/ 1.57); 	 // Phasen des Winkels (je Viertelkreis, 90deg, 1.57rad)
	switch (pw){
		case  1: hochfalten(paketGeo,w);
		     	 hochfalten(paketFaltGeo,w);
		    	 break;		 		 
		case  2: deckeldrauf(paketGeo,w);
				 deckeldrauf(paketFaltGeo,w);
				 break;						
		case  3: deckelauf(paketGeo,w);
	 			 deckelauf(paketFaltGeo,w);
				 break;
		case  4: camera.position.y += 0.5; 		 // Kamerafahrt
				 camera.position.z += 0.2;  
				 break;				
		case  5: case 6:						 // MiniAndro schwebt ein	
				 if (miniandro.position.x >0) {   		
					miniandro.position.x -= 0.45;          
					miniandro.position.z += 0.3;  
					perle.position.x 	 -= 0.45;          
					perle.position.z		 += 0.3;  					
				 }	
				 break;				
		case  7: 								 // MiniAndro abwaerts	
				 if ( miniandro.position.y >22){
					miniandro.position.y -= 0.2;
					perle.position.y 	 -= 0.2;
				 }
				 miniandro.rotation.y -= 0.06;		
				 break;
		case  8: miniandro.position.y += (w-pw)*(w-pw)*0.1; // MiniAndro aufwaerts			                
	    		 camera.position.y -= 0.35; 	 // Kamerafahrt
				 camera.position.z -= 0.15; 		
				 schneemann.position.x -= 0.1;   // Schneemann zum Paket
				 break;
		case  9: deckelzu(paketGeo,w);
				 deckelzu(paketFaltGeo,w);
				 schneemann.position.x -= 0.1;   // Schneemann zum Paket
				 break;				
		case 10: schneemann.rotation.y -= 0.005; // Schneemann schiebt Paket
				 schneemann.position.x -= 0.12; 
				 schneemann.position.z -= 0.18;	
				 paket.position.x      -= 0.12; // Paket unter den Baum
				 paketFalt.position.x  -= 0.12;
				 perle.position.x      -= 0.12;
				 paket.position.z      -= 0.18;		
				 paketFalt.position.z  -= 0.18;
				 perle.position.z      -= 0.18;
				 camera.position.x -= 0.3;  	 // Kamerafahrt
	    		 camera.position.y -= 0.2; 
				 camera.position.z -= 0.1; 		
				 break;	
		case 11: schneemann.rotation.y += 0.015; // Schneemann dreht sich
			 	 camera.position.y += 0.35; 	 // Kamerafahrt
				 camera.position.z += 0.15;
				 break;	
		case 12: schneemann.position.x += 0.35;   // Schneemann geht
				 schneemann.position.z += 0.2;
				 camera.position.x += 0.01; 	 // Kamerafahrt
			 	 camera.position.y += 0.35; 	 
				 camera.position.z += 0.15; 
				 schneeSystem.visible = true;
				 break;	
		case 13: camera.position.x -= 0.01; 	 // Kamerafahrt
			 	 camera.position.y += 0.35; 	 
				 camera.position.z += 0.15; 
				 schneeSystem.position.x +=	0.1; // Schneefall	
				 schneeSystem.position.y -=	0.5;
				 schneeSystem.position.z +=	0.5;
				 break;
		case 14: //  --- Neustart der Animation ---
			 	 schneeSystem.visible = false;			
				 schneeSystem.position.z = 150;
				 schneeSystem.position.y = 250;
				 resetpos();                     // Anfangskoordinaten und -Rotationen
			     t0 = clock.getElapsedTime();    // Beginn in der Animation					   	
				 break; 	
	} // end switch
	renderer.render(scene, camera);
}
window.onload = init();
resetpos();  // Anfangswerte setzen
animate();
//----------------------------------
</script>
</html>