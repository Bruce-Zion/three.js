<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cube folding and expanding by LiYajun</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #c0c0c0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
        
        <button id="run"> 
            PressMe 
        </button>

		<script src="../build/three.js"></script>

        <script src="js/libs/dat.gui.min.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/libs/tween.min.js"></script>
        <script src="js/controls/DragControls.js"></script>

		<script>
            
            //https://stackoverflow.com/questions/41320005/folding-rectangles-to-form-a-cube-using-three-js
            //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model 补习Java
            //https://bl.ocks.org/mpmckenna8/e0e3a8f79c711b29c55f (three.js child moves and rotates w/ parent)
            //http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/ (OpenGL tutorial)
            
            var camera, scene, renderer, controls;
            var sides = [];
            var clock = new THREE.Clock();
            init();
            animate();

            function init() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(105, window.innerWidth / window.innerHeight, 1, 1000);
                camera.position.set(-0.5, 0.5, 1).setLength(5);

                // Grid
                gridHelper = new THREE.GridHelper( 10, 10 );
                scene.add(gridHelper);

                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0xc0c0c0);
                document.body.appendChild(renderer.domElement);

                controls = new THREE.OrbitControls(camera, renderer.domElement);

                //sides
                var geom = new THREE.PlaneGeometry(1,1);
                var side0 = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({color: "white", wireframe: true}));
                scene.add(side0);
                
                var side1Geom = new THREE.PlaneGeometry(1,1);
                side1Geom.translate(-0.5,0,0);
                var side1 = new THREE.Mesh(side1Geom, new THREE.MeshBasicMaterial({color: "white", wireframe: true}));
                sides.push(side1);
                
                //////////////////////////////////
                //test
                /*
                geom.computeBoundingBox();
                side1Geom.computeBoundingBox();
                console.log((geom.boundingBox.max.x + geom.boundingBox.min.x ) / 2);  
                console.log((geom.boundingBox.max.y + geom.boundingBox.min.y ) / 2);  
                console.log((geom.boundingBox.max.z + geom.boundingBox.min.z ) / 2);  
                console.log( geom.center() ); 
                console.log((side1Geom.boundingBox.max.x + side1Geom.boundingBox.min.x ) / 2);  
                console.log((side1Geom.boundingBox.max.y + side1Geom.boundingBox.min.y ) / 2);  
                console.log((side1Geom.boundingBox.max.z + side1Geom.boundingBox.min.z ) / 2);  
                console.log( side1Geom.center() );
                //////////////////////////////////////////////////////////////
                */
                

                var side2 = side1.clone(); sides.push(side2);
                var side3 = side1.clone(); sides.push(side3);
                var side4 = side1.clone(); sides.push(side4);
                var side5 = side1.clone(); sides.push(side5);
                side5.material = new THREE.MeshBasicMaterial({color: "blue", side: THREE.DoubleSide});
                //var texture = new THREE.TextureLoader().load( "textures/brucetest/square-outline-textured.png" );
                //side5.material = new THREE.MeshLambertMaterial( { color: 0xfeb74c, map: texture, side: THREE.DoubleSide } );
               
                // hierarchy
                side1.position.set(-0.5,0,0); side0.add(side1);
                side2.position.set(0,-0.5,0); side2.rotation.z = Math.PI / 2; side0.add(side2);
                side3.position.set(0.5,0,0); side3.rotation.z = Math.PI; side0.add(side3);                
                side4.position.set(-0.5,-0.5,0); side4.rotation.z = Math.PI / 2; side3.add(side4);                
                side5.position.set(-0.5,0.5,0); side5.rotation.z = -Math.PI / 2; side4.add(side5);
                

                document.getElementById("run").addEventListener("click", foldTheCube);

            }

            function foldTheCube(){
                var start = {value: 0};
                var finish = {value: Math.PI / 2};
                var angle = 0;
                new TWEEN
                .Tween(start)
                .to(finish, 3000)
                .easing(TWEEN.Easing.Sinusoidal.InOut)
                .onUpdate(function(){
                    angle = this.value;
                    sides[0].rotation.y = angle;
                    sides[1].rotation.x = -angle;
                    sides[2].rotation.y = -angle;
                    sides[3].rotation.x = -angle;
                    sides[4].rotation.x = angle;
                })
                .start();
            }

            // animate
            function animate() {
              requestAnimationFrame(animate);
              TWEEN.update();
              render();
            }

            function render() {
              renderer.render(scene, camera);
            }
            
            
            /*
            //https://jsfiddle.net/prisoner849/za29828m/
            var camera, scene, renderer, controls;
            var sides = [];
            var clock = new THREE.Clock();
            init();
            animate();

            function init() {

              scene = new THREE.Scene();
              camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
              camera.position.set(0, 0, 1).setLength(5);

              renderer = new THREE.WebGLRenderer({
                antialias: true
              });
              renderer.setSize(window.innerWidth, window.innerHeight);
              document.body.appendChild(renderer.domElement);

              controls = new THREE.OrbitControls(camera, renderer.domElement);

              //sides
              var geom = new THREE.PlaneGeometry(1, 1);
              for (var i = 0; i < 5; i++) {
                var s = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({
                  color: Math.random() * 0xffffff,
                  wireframe: true
                }));
                s.position.set(Math.random() * 5 - 2.5, Math.random() * 5 - 2.5, 0);
                scene.add(s);
                //sides.push(s);
              }
              var material = new THREE.MeshBasicMaterial({
                color: "blue",
                side: THREE.DoubleSide
              });
              var side = new THREE.Mesh(geom, material);
              sides.push(side);
              scene.add(side);

              var dragControls = new THREE.DragControls(sides, camera, renderer.domElement);
              dragControls.addEventListener('dragstart', function(event) {
                controls.enabled = false;
              });
              dragControls.addEventListener('dragend', function(event) {
                controls.enabled = true;
              });

            }

            function animate() {
              requestAnimationFrame(animate);
              render();
            }

            function render() {
              renderer.render(scene, camera);
            }
            */

		</script>

	</body>
</html>
